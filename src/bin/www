#!/usr/bin/env node

/**
 * Module dependencies.
 */
const app = require('../app')
const debug = require('debug')('wisnuc-drop:server')
const cluster = require('cluster')
const http = require('http')
const config = require('getconfig')
const numCPUs = require('os').cpus().length
const port = process.env.PORT || config.port

const Logger = require('../utils/logger').Logger('cluster')

if (cluster.isMaster) {
	for (let i = 0; i < numCPUs; i++) {
		cluster.fork()
	}
	cluster.on('fork', (worker) => {
		Logger.info(`Worker ${worker.process.pid} fork pid: ${worker.process.pid}`)
	})
	cluster.on('exit', (worker, code, signal) => {
		Logger.log(`Worker ${worker.process.pid} died.`)
	})
}
else {
	// app.set('port', port)
	// app.listen(port, () => {
	// 	Logger.info(`wisnuc-drop listening on port: ${port}`)
	// })

	app.set('port', port)
	/**
	 * Create HTTP server.
	 */
	const server = http.createServer(app)

	/**
	 * socket.io 
	 */
	const io = require('socket.io')(server)
	require('../lib/socketIO')(io)

	// ####################### session #########################
	// FIXME: delete session
	const session = require('express-session')({
		secret: 'wisnuc-drop',
		resave: false,
		saveUninitialized: false
	})

	// TODO: 更改 session
	const sharedsession = require('express-socket.io-session')

	// Use express-session middleware for express
	app.use(session)

	// Use shared session middleware for socket.io
	// setting autoSave:true
	io.use(sharedsession(session, {
		autoSave: true
	}))
	// ####################### session #########################

	/**
	 * Event listener for HTTP server 'error' event.
	 */
	const onError = error => {
		if (error.syscall !== 'listen') {
			throw error
		}

		var bind = typeof port === 'string' ?
			'Pipe ' + port :
			'Port ' + port

		// handle specific listen errors with friendly messages
		switch (error.code) {
			case 'EACCES':
				console.error(bind + ' requires elevated privileges')
				process.exit(1)
				break;
			case 'EADDRINUSE':
				console.error(bind + ' is already in use')
				process.exit(1)
				break;
			default:
				throw error
		}
	}

	/**
	 * Event listener for HTTP server 'listening' event.
	 */
	const onListening = () => {
		var addr = server.address()
		var bind = typeof addr === 'string' ?
			'pipe ' + addr :
			'port ' + addr.port

		console.info('Listening on ' + bind)
		debug('Listening on ' + bind)
	}

	/**
	 * Listen on provided port, on all network interfaces.
	 */

	server.listen(port)
	server.on('error', onError)
	server.on('listening', onListening)

	// FIXME: deal with Unhandled rejection Error
}
